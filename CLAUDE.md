# CLAUDE.md

이 파일은 해당 리포지토리에서 작업할 때 Claude Code (claude.ai/code)에게 가이드를 제공합니다.

## 프로젝트 개요

이것은 쇼핑카트 기능에 중점을 둔 **챕터 2-1의 클린 코드 리팩토링 과제**입니다. 모든 원본 기능을 보존하면서 더러운 JavaScript 코드를 깨끗하고 유지보수 가능한 코드로 변환하는 프로젝트입니다.

### 2단계 접근법
- **기본 과제** (`/src/basic`): 클린 코드 원칙에 따라 바닐라 JavaScript 더러운 코드를 깨끗한 코드로 리팩토링
- **고급 과제** (`/src/advanced`): 더 나은 유지보수성을 위해 기본 리팩토링된 코드를 React + TypeScript로 업그레이드

## 개발 명령어

### 패키지 매니저
**pnpm** 사용 (npm이나 yarn 대신):
```bash
pnpm install
pnpm dev
```

### 개발 서버
- **기본 버전**: `pnpm start:basic` (index.basic.html 열기)
- **고급 버전**: `pnpm start:advanced` (index.advanced.html 열기)
- **일반 개발 서버**: `pnpm dev`

### 테스트
- **모든 테스트**: `pnpm test`
- **기본 테스트만**: `pnpm test:basic`
- **고급 테스트만**: `pnpm test:advanced`
- **테스트 UI**: `pnpm test:ui`

### 코드 품질 & 린팅
- **린트**: `pnpm lint`
- **자동 수정 린팅**: `pnpm lint:fix`
- **포맷 확인**: `pnpm format`
- **자동 포맷**: `pnpm format:fix`

### 빌드 & 배포
- **빌드**: `pnpm build`
- **미리보기**: `pnpm preview`

## 아키텍처 & 구조

### 핵심 애플리케이션 로직
쇼핑카트는 복잡한 할인 및 재고 관리 시스템을 구현합니다:

**상품 관리**:
- 개별 가격 및 재고 수준을 가진 5개의 개발자 테마 상품
- 시각적 표시기(재고 부족, 품절)를 사용한 실시간 재고 추적
- 장바구니 작업 시 재고 검증

**다층 할인 시스템**:
- **개별 상품 할인**: 10개 이상 수량 시 상품별 특정 할인율 적용
- **대량 할인**: 총 장바구니 수량 ≥30개 시 25% 할인
- **특별 프로모션**:
  - 화요일 10% 할인 (요일 기반)
  - 번개세일 ⚡ (랜덤 타이밍, 랜덤 상품 20% 할인)
  - 추천할인 💝 (다른 상품 제안 및 5% 할인)
  - 슈퍼세일 (번개 + 추천 모두 활성화 시 25%)

**포인트 시스템**:
- 기본: 최종 금액의 0.1% (1000원당 1포인트)
- 화요일 2배 포인트
- 콤보 보너스 (키보드+마우스, 풀세트)
- 수량 보너스 (10+, 20+, 30+ 아이템)

### 파일 구조
```
src/
├── basic/
│   ├── main.basic.js          # 리팩토링할 더러운 코드
│   └── __tests__/
│       └── basic.test.js      # 종합적인 테스트 스위트
├── advanced/
│   ├── main.advanced.js       # React + TypeScript 구현
│   └── __tests__/
│       └── advanced.test.js   # 고급 테스트 스위트
├── main.original.js           # 원본 참조 코드
└── setupTests.js              # 테스트 설정

docs/
├── 01-PRD.md                  # 완전한 제품 요구사항
├── 02-dirty-code-analysis.md # 코드 품질 분석
├── 03-cart-tailwind-evaluation.md
├── 04-practical-clean-code-guide.md
└── 05-clean-code-theory-lesson.md
```

## 주요 구현 요구사항

### 기능적 요구사항 (협상 불가)
1. **모든 테스트가 통과해야 함** - 테스트 스위트가 정확한 동작 일치를 검증
2. **실시간 계산** - 모든 가격, 할인, 포인트가 즉시 업데이트
3. **재고 관리** - 재고 수준이 정확하게 추적되고 검증되어야 함
4. **복잡한 할인 로직** - 적절한 우선순위를 가진 다층 할인 시스템
5. **반응형 UI** - Tailwind CSS를 사용한 모바일 및 데스크톱 레이아웃

### 코드 품질 표준
- **ESLint + Prettier** pre-commit hook을 통해 강제
- **컨벤셔널 커밋** 필수 (commitlint)
- **클린 코드 원칙**: 의미 있는 이름, 단일 책임, 최소 복잡성
- **테스트 주도 접근법**: 100% 테스트 호환성 유지
- **React 준비 리팩토링**: 기본 코드 리팩토링 시 React 마이그레이션에 최소한의 변경이 필요하도록 구조화

### 기술적 제약사항
- **기본 버전**: 바닐라 JavaScript ES6+ 만
- **고급 버전**: React + TypeScript (프레임워크 선택 유연)
- **스타일링**: Tailwind CSS (CDN 기반)
- **테스팅**: jsdom 환경의 Vitest

## 개발 워크플로우

### Pre-commit 품질 게이트
프로젝트는 다음과 함께 Husky를 사용합니다:
- **lint-staged**: ESLint/Prettier 이슈 자동 수정
- **commitlint**: 컨벤셔널 커밋 형식 강제

### 리팩토링 전략
**점진적 리팩토링**을 따르세요:
1. 테스트 호환성을 유지하면서 작고 집중된 변경 수행
2. 정확한 동작을 보존하면서 함수/모듈 추출
3. 이름과 구조를 점진적으로 개선
4. React 마이그레이션을 위해: 점진적으로 컴포넌트화

### 중요한 비즈니스 로직 영역
할인 계산 작업 시 다음에 특히 주의하세요:
- **할인 우선순위**: 개별 vs 대량 vs 특별 프로모션
- **시간 기반 기능**: 화요일 할인 및 랜덤 세일 타이밍
- **상태 동기화**: 장바구니 상태, 재고, UI가 일관성을 유지해야 함
- **엣지 케이스**: 품절 처리, 수량 제한, 할인 조합

## 테스트 접근법

테스트 스위트는 다음을 종합적으로 검증합니다:
- **상품 선택 및 장바구니 작업**
- **모든 할인 시나리오 및 조합**
- **재고 관리 및 제약사항**
- **포인트 계산 정확성**
- **UI 상태 동기화**

테스트는 리팩토링 과정에서 동작 일치를 보장하기 위해 기본 및 고급 구현 모두에 대해 실행됩니다.

## 📦 클린 코드 & 리팩토링 원칙 (커스텀 규칙)

### 🛡️ 커스텀 클린 코드 & 리팩토링 규칙

이 리포지토리에서 작업할 때 **다음 원칙을 항상 엄격히 준수하세요:**

---

#### **가독성 및 유지보수성 우선**
- 모든 코드는 미래의 엔지니어가 읽기 쉽고, 이해하기 쉽고, 수정하기 쉬워야 합니다.
- 변수, 함수, 컴포넌트에 **의미 있고 설명적인 이름**을 사용하세요.
- 불필요한 축약어와 모호한 이름을 피하세요.

---

#### **단일 책임 원칙 (SRP)**
- 각 함수, 모듈, 컴포넌트는 **하나의 명확한 목적**을 가져야 합니다.
- 함수가 너무 길어지거나 여러 관심사를 처리하면 추출하고 분할하세요.

---

#### **최소 복잡성, 과도한 엔지니어링 금지**
- 영리한 트릭이나 불필요한 추상화보다 단순하고 직관적인 로직을 선호하세요.
- 깊은 중첩과 긴 매개변수 목록을 피하세요.
- "혹시 모르니까"라는 이유로 패턴, 훅, 또는 추상화를 도입하지 마세요 — 명확히 필요할 때만 사용하세요.

---

#### **일관된 코딩 스타일**
- ESLint, Prettier, 그리고 프로젝트 규약을 **항상** 따르세요.
- 프로젝트 전체에서 동일한 포맷팅, 임포트 순서, 코드 구조를 일관되게 사용하세요.

---

#### **매직 넘버나 문자열 금지**
- 모든 상수(숫자, 텍스트, 선택자 등)는 이름을 붙이고 전용 변수나 설정으로 추출해야 합니다.

---

#### **점진적, 테스트 보존 리팩토링**
- 모든 단계에서 모든 테스트가 통과하도록 유지하면서 **작고 안전한 단계**로 리팩토링하세요.
- 각 변경 후 항상 전체 테스트 스위트를 실행하세요.
- 테스트가 실패하면 진행하기 전에 코드를 수정하거나 필요에 따라 테스트를 업데이트하세요.

---

#### **관심사의 분리**
- UI 로직과 비즈니스 로직을 명확히 분리하세요.
- 동일한 함수에서 DOM 조작, 상태 업데이트, 계산 코드를 섞지 마세요.

---

#### **중복 피하기**
- 절대 반복하지 마세요(DRY). 공유 로직을 유틸리티 함수나 모듈로 추출하세요.

---

#### **예측 가능한 데이터 흐름**
- 상태는 항상 모듈/컴포넌트 간에 명확하고 명시적으로 흘러야 합니다.
- 숨겨진 변이와 암시적 부작용을 피하세요.

---

#### **문서화 및 주석**
- "무엇"이 아닌 "왜"를 설명하기 위해 **필요할 때만** 주석을 추가하세요.
- 공개 함수, 내보낸 모듈, 복잡한 비즈니스 로직은 문서화되어야 합니다.
- **모든 주석과 문서는 [JSDoc](https://jsdoc.app/) 형식을 사용하고 한국어로 작성되어야 합니다.**

---

#### **커밋 관행**
- 모든 커밋은 논리적 변경 단위를 나타내고 **컨벤셔널 커밋 표준**을 따라야 합니다.
- "WIP"/"fix stuff"/"misc" 커밋은 금지합니다.

---

### 🏆 커스텀 리팩토링 가이드라인

- 리팩토링된 코드는 **단순히 작동하는 것뿐만 아니라** **주니어 개발자를 위한 모범 사례**로 간주되어야 합니다.
- 트레이드오프가 필요한 경우, **미세 최적화보다 명확성과 유지보수성을 선호**하세요.
- React 마이그레이션을 최소한의 미래 변경으로 수행할 수 있도록 항상 코드를 준비하세요.

---

### **적용 방법**

- Claude Code나 AI/에이전트가 이 리포에서 작업할 때,  
  **모든 코드 제안, 수정, 리팩토링은 이 규칙을 만족해야 합니다.**
- 트레이드오프가 필요한 경우(예: 성능 vs 명확성),  
  **항상 결정을 설명하고 추론을 문서화하세요.**


